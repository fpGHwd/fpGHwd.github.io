<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wd's blog (Posts about emacs)</title><link>https://fpghwd.github.io/</link><description></description><atom:link href="https://fpghwd.github.io/categories/emacs.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:ggwdwhu@gmail.com"&gt;suzumiya natsuhi&lt;/a&gt; </copyright><lastBuildDate>Tue, 15 Dec 2020 08:13:58 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Emacs 下同时查看和编辑一个文件的多个 headline: 使用 Indirect Buffer</title><link>https://fpghwd.github.io/posts/emacs-open-several-windows-with-specific-org-narrowed-headline/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
在使用 emacs 编辑一个很多的 headlines 的 org 文件时，如果每个 headline 下的内容需要交叉查看和编辑的时候，我就非常需要一个单独的 windows(emacs 下的窗口，下均同) 仅显示一个 headline 下的所有内容，所以必须用到 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 这个函数。
&lt;/p&gt;

&lt;p&gt;
但是在第一次使用这个函数后，就无法看到其他的 headlines ，所以想在多个窗口中打开多个 headlines 仅使用 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 是不够的。好在有了 &lt;code&gt;clone-indirect-buffer&lt;/code&gt; 可以复制一个当前文件的 buffer 。一般情况下，在使用 emacs 打开文件的时候，我们只能在将一个文件绑定在一个 buffer 中，这个函数可以让我们将一个文件绑定在多个 buffer 中。
&lt;/p&gt;

&lt;p&gt;
然后在不同的 windows 中打开相同文件的不同 buffer ，可以看到这个文件的不同 headlines ，进而使用对不同的 headline 使用 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 来实现“在不同的 windows 里面查看一个文件中不同 headlines 的 &lt;code&gt;org-narrow-subtree&lt;/code&gt; ”。
&lt;/p&gt;

&lt;p&gt;
这个功能对于我来说很实用，尤其是对一个比较长的， subtree 又比较多的 org 文件中同时查看和编辑多个 headline 的情况下尤其有用。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-open-several-windows-with-specific-org-narrowed-headline/</guid><pubDate>Tue, 15 Dec 2020 00:04:30 GMT</pubDate></item><item><title>Emacs 使用感受</title><link>https://fpghwd.github.io/posts/emacs-shi-yong-gan-shou/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
不知不觉使用 emacs 已经有两年了。其实一开始看 Emacs 那篇自带的极短的介绍要更早一点，现在看当时的那种喜悦的感觉（用上了众多名人都推荐的软件）更多的是 naive 和开心。
&lt;/p&gt;

&lt;p&gt;
后来从开始使用无配置的 emacs ，然后用 Spacemacs 的时候有眼前有一亮的感觉。然后逐渐学习使用 org-mode 并且针对 org-mode 进行自己的配置，也收获了很多开心的时光。
&lt;/p&gt;

&lt;p&gt;
慢慢的又转向使用 doom-emacs 感觉又有眼前一亮的感觉，主要是启动速度更快了，然后基本上开箱即用。然后也学到一些自己配置的方法，虽然 spacemacs 也可以自定义，但是启动一次还是蛮长的。
&lt;/p&gt;

&lt;p&gt;
然后逐渐学到了 org-roam, org-download, org-capture, org-pdftool 等等都是很好用的插件。不过现在已经很少纠结于配置了，现在的已经够用了。
&lt;/p&gt;

&lt;p&gt;
最后的最后，送一句传教语：
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Emacs loves me, emacs loves you.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-shi-yong-gan-shou/</guid><pubDate>Thu, 10 Dec 2020 02:23:53 GMT</pubDate></item><item><title>linux 平台下 emacs native-comp 分支编译</title><link>https://fpghwd.github.io/posts/linux-ping-tai-xia-emacs-native-comp-fen-zhi-bian-yi/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;ul class="org-ul"&gt;
&lt;li&gt;编译 libgccjit

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
下载 gcc
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;git clone git://gcc.gnu.org/git/gcc.git&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
然后切换到目录 &lt;code&gt;cd gcc&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
切换分枝
&lt;/p&gt;

&lt;p&gt;
切换 gcc-9 分枝 &lt;code&gt;git checkout remotes/origin/releases/gcc-9&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
创建 build 目录 &lt;code&gt;mkdir -p build&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
进入 build 目录 &lt;code&gt;cd build&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
configure
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;../configure --enable-host-shared --enable-languages=jit,c,c++,objc,obj-c++ --enable-checking=release --disable-bootstrap&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
编译
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;make -j8&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
安装（默认到 &lt;code&gt;/usr/local&lt;/code&gt; ）
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo make install&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
加载库
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo ldconfig&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
测试是否能发现 libgccjit 库 &lt;code&gt;sudo ldconfig -p | grep libgccjit&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;编译 emacs

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
下载 emacs
&lt;/p&gt;

&lt;p&gt;
克隆 emacs 仓库 &lt;code&gt;git clone https://github.com/emacs-mirror/emacs&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
进入 emacs 目录 &lt;code&gt;cd emacs&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
切换到 native-comp 分枝 &lt;code&gt;git checkout feature/native-comp&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
进入 emacs 目录后运行 autogen.sh
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;./autogen.sh&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
编译 emacs
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;./configure --with-nativecomp CC=clang&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
安装（默认 &lt;code&gt;/usr/local&lt;/code&gt; ）
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo make install&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;启动 doom emacs

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
&lt;del&gt;启动的时候如果报错&lt;/del&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;comp-deferred-compilation-black-list&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
然后找到&lt;a href="https://github.com/hlissner/doom-emacs/issues/4316"&gt;这里&lt;/a&gt;解决：注释掉 &lt;code&gt;.emacs.d/core/core.el&lt;/code&gt; 里面的一个过程 &lt;code&gt;(add-to-list 'comp-deferred-compilation-black-list entry)&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
doom build and run
&lt;/p&gt;

&lt;p&gt;
升级 doom ，包含 doom sync 和 doom build 过程 &lt;code&gt;doom upgrade&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
查看 doom 是否是使用 emacs 28 版本 &lt;code&gt;doom run --version&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
若确认是 emacs 28 版本，就可运行 &lt;code&gt;doom run&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
最后
&lt;/p&gt;

&lt;p&gt;
确实有流畅很多，也可能是心理作用吧。 :)
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/linux-ping-tai-xia-emacs-native-comp-fen-zhi-bian-yi/</guid><pubDate>Thu, 26 Nov 2020 01:53:27 GMT</pubDate></item><item><title>Difference Since Using Doom Emacs</title><link>https://fpghwd.github.io/posts/since-use-doom-emacs/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
自从使用了 doom emacs 后，就很少纠结系统升级了。以前没事总是会升级一下，但是现在最多的就是可能想起来会升级一下 doom emacs, 只需要在 emacs 中 upgrade 和 reload 即可。其实大多数时候我也只是 doom sync 一下配置然后 reload 一下，最多也就十几二十秒。
&lt;/p&gt;

&lt;p&gt;
用 emacs 写东西简直是最近感觉最幸福的一件事情了。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/since-use-doom-emacs/</guid><pubDate>Wed, 04 Nov 2020 19:13:58 GMT</pubDate></item><item><title>Emacs Lisp Overlay</title><link>https://fpghwd.github.io/posts/emacs-lisp-overlay/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近看到 Emacs Lisp 里面 Overlay 的概念，可以用于自定义介面 buffer 的文字的某些特殊效果。
&lt;/p&gt;

&lt;p&gt;
当然其实对文字的编辑和模式本身都可以是文字内容的一种展现方式，但是文字的属性（Text Properties）是文字的一部分，overlay 并不是文字的一部分。所以在 buffer 之间复制某些文字的时候，并不会同时复制  overlay ；同时改变 buffer 的文字属性其实也是在修改 buffer 本身。但 overlay 的改变并不会改变 buffer 本身，这种修改自然也不会被保存在这个 buffer 的 undo list 中。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-lisp-overlay/</guid><pubDate>Mon, 26 Oct 2020 05:24:03 GMT</pubDate></item><item><title>Org archive location</title><link>https://fpghwd.github.io/posts/org-archive-location/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在使用 org 的时候想把 org-archive-subtree 的条目和 org-capture-templates 那样，将每次当天 archived 的 headline 放到当日的日期 headline 下面，和日记一样组织。这样的话，将来查询的时候就可以顺便看一下当天发生的事情和当天完成的项目了。
&lt;/p&gt;

&lt;p&gt;
以下是日记的组织方式：
&lt;/p&gt;

&lt;div id="org595b26c" class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/_20201016_192526screenshot.png" alt="_20201016_192526screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;
(add-to-list 'org-capture-templates
                      '("zj" "journal" entry (file "/home/wd/dropbox/to-encfs/text/org/journal.org")
                        "* %u - %^{heading}\n  %?"))

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
同时在 &lt;code&gt;customize org-archive-location&lt;/code&gt; 中发现了有这种设定：
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
"~/org/datetree.org::datetree/* Finished Tasks"
The "datetree/" string is special, signifying to archive
items to the datetree.  Items are placed in either the CLOSED
date of the item, or the current date if there is no CLOSED date.
The heading will be a subentry to the current date.  There doesn’t
need to be a heading, but there always needs to be a slash after
datetree.  For example, to store archived items directly in the
datetree, use "~/org/datetree.org::datetree/".

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
可以把日记和归档的条目都放到一个文件，归档也不会经常去动，只需要看的时候搜索一下就行。
&lt;/p&gt;&lt;/div&gt;</description><category>ATTACH</category><category>emacs</category><guid>https://fpghwd.github.io/posts/org-archive-location/</guid><pubDate>Fri, 16 Oct 2020 03:32:18 GMT</pubDate></item><item><title>Org2nikola image displaying</title><link>https://fpghwd.github.io/posts/org2nikola-image-display/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;b&gt;设置&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
先&lt;a href="https://github.com/redguardtoo/org2nikola/issues/11"&gt;咨询&lt;/a&gt;了作者，然后得到了思路：获得一个对 output html 进行自定义 render 的函数，然后自定义修改 html 。
&lt;/p&gt;

&lt;p&gt;
设置 org2nikola 包变量的 &lt;code&gt;org2nikola-process-output-html-function&lt;/code&gt; 为：
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;
(setq org2nikola-process-output-html-function
 (lambda (html-text title post-slug)
   (progn (let* ((re-str "\\/home\\/.+?\\.\\(png\\|jpg\\|jpeg\\|bmp\\)"))
            (let* ((files-list (s-match-strings-all re-str html-text)))
              (dolist (file-path files-list)
                (message (format "file-path: %s" (car file-path)))
                (setq cmd (format "cp %s /home/wd/.config/nikola/images/" (car file-path)))
                (message cmd)
                (shell-command cmd))))
          (replace-regexp-in-string
           "file:.+?\\/[a-z0-9-]\\{34\\}\\/"
           "https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/"
           html-text))))

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
其中用到了 &lt;code&gt;s-match-strings-all&lt;/code&gt; 和 &lt;code&gt;replace-regexp-in-string&lt;/code&gt; 两个函数。
&lt;/p&gt;

&lt;p&gt;
整个过程中最重要的还是匹配文件地址和修改 github 图片资源 url 的两个正则表达式。我需要匹配字符串的是（目前只能匹配一个字符串，如果贴文本的话，写好博客后进行处理后面的真正图片的链接就不能进行转换了，所以用图片代替）：
&lt;code&gt;找不到图片了算了)○(￣□￣○)&lt;/code&gt; 。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;获取图片地址&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
我需要将图片的地址拿到并复制到 nikola/images 目录，这样 nikola 在发布的时候会对图片做一些处理，然后输出到 output/images 中。使用的正则是 &lt;code&gt;\\/home\\/.+?\\.\\(png\\|jpg\\|jpeg\\|bmp\\)&lt;/code&gt; 。
&lt;/p&gt;

&lt;div id="org69cde4d" class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/_20200918_123005screenshot.png" alt="_20200918_123005screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;替换图片地址&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
我需要将形如 &lt;code&gt;file:///home/wd/Dropbox/text/org/.attach/(HashI/(UUID)/&lt;/code&gt; 的所有字符串替换为 &lt;code&gt;https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/&lt;/code&gt; ，使用的正则是 &lt;code&gt;"file:.+?\\/[a-z0-9-]\\{34\\}\\/&lt;/code&gt; 。
&lt;/p&gt;

&lt;div id="orgd2806f2" class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/_20200918_122914screenshot.png" alt="_20200918_122914screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;调试正则&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
用到了 emacs 自带的 &lt;code&gt;re-builder&lt;/code&gt; 来对当前 buffer 测试正则表达式，很好用。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;TODO&lt;/b&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;由于没有循环，只能找到第一个图片的字符串然后替换成真实的 url, 需要完善匹配后的操作。（完成）&lt;/li&gt;
&lt;li&gt;还只能匹配截图这样文件名的图片，需要完善正则表达式。（完成）&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description><category>ATTACH</category><category>emacs</category><guid>https://fpghwd.github.io/posts/org2nikola-image-display/</guid><pubDate>Wed, 16 Sep 2020 19:35:39 GMT</pubDate></item><item><title>Manage workgroups in emacs via workgroups2</title><link>https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;b&gt;Workgroups2&lt;sup&gt;&lt;a id="fnr.1" class="footref" href="https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/#fn.1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/b&gt; 
Workgroups2 是一款保存和恢复用户工作空间的一款 emacs 插件。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;sessions 和 workgroups&lt;/b&gt; 
这里的 session 指的是 emacs 里面的 buffer 的一个集合，甚至 buffer 的指针的状态即位置。workgroups 与用户的工作相关，指的是用户指定的显示 buffer 和 buffer 的状态集合。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;如何管理：group 的创建/修改/删除&lt;/b&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;wg-create-group&lt;/code&gt; 用于创建一个 group（比如 cpp-dev），可以用 &lt;code&gt;wg-rename-group&lt;/code&gt; 修改 group 的名字，然后使用 &lt;code&gt;wg-save-session&lt;/code&gt; 将当前的 group 的状态保存入文件中（比如 &lt;code&gt;~/.emacs_workgroups&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wg-rename-group&lt;/code&gt; 用于修改 group 的名字，然后用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。同时如果想保存指针（cursor）在另一个位置的状态，需要重新用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wg-kill-workgroup&lt;/code&gt; 用于删除打开的 group，同时完成后用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;b&gt;意义&lt;/b&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;在多个 workgroups 之间切换将会变得很容易。当然可以使用 &lt;code&gt;C-x b&lt;/code&gt; 来切换 buffer，但是使用了 workgroups 后一次切换到你所指定的所需 buffer 集合，将是一个极大的效率提升。&lt;/li&gt;
&lt;li&gt;保存共享同步 workgroups。这个是一个次要的提升，由于在不同环境中的文件可能不同，buffer 是否能够正常打开并不确定。如果依赖同步来同步整个环境的话我感觉没有必要，毕竟在对应的环境中做什么事情效率更高一些。&lt;/li&gt;
&lt;/ol&gt;

&lt;div id="footnotes"&gt;
&lt;h3 class="footnotes"&gt;Footnotes: &lt;/h3&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.1" class="footnum" href="https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/#fnr.1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
&lt;a href="https://github.com/pashinin/workgroups2"&gt;Workgroups2的Github主页&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>workgroups2</category><guid>https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/</guid><pubDate>Thu, 09 Jul 2020 02:08:16 GMT</pubDate></item><item><title>Makefile</title><link>https://fpghwd.github.io/posts/makefileemacs/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;b&gt;预警&lt;/b&gt;
本文可能没有重点，我觉得博客改个更日常的标题更为合适:)
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;makefile&lt;/b&gt;
很多年前自学了 makefile，但是当时特别想搞懂但后来的印象还是没搞懂。后来就不了了之也免不了心心念念。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;emacs&lt;/b&gt;
提到 emacs 的原因是整个过程都是用 emacs 来做的，虽然很多人说 emacs 始终是一个编辑器。但是对于我来说 emacs 可能是一种态度：对于自己不了解的东西的好奇心吧。也是现阶段我最喜欢的态度了。从开始用 emacs 到现在也快两年的时间了，也收获不少。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;english&lt;/b&gt;
想这些旅程也离不开英语的陪伴，曾经也吃过英语的亏，英语也是国际化所必须要掌握的一个工具。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>makefile</category><guid>https://fpghwd.github.io/posts/makefileemacs/</guid><pubDate>Wed, 08 Jul 2020 19:45:25 GMT</pubDate></item></channel></rss>