<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wd's blog</title><link>https://fpghwd.github.io/</link><description>To iterate is human, to recurse, divine</description><atom:link href="https://fpghwd.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:ggwdwhu@gmail.com"&gt;suzumiya natsuhi&lt;/a&gt; </copyright><lastBuildDate>Thu, 26 Nov 2020 09:53:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>《狗镇》</title><link>https://fpghwd.github.io/posts/kan-wan-dian-ying-gou-zhen-de-yi-dian-xiang-fa/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
Grace 重新见到父亲时，父亲说了以下的话：
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
你错了，他们犯下的错误，只是因为他们在服从自己的本性。原谅，宽恕，是在纵容罪恶。你要宽恕他们，原谅他们，才是真正的傲慢。因为只有上帝才有资格去宽恕人类的罪责，去原谅他们的错误。当你要原谅所有有罪之人的时候，就是在傲慢地将自己比肩上帝。但你却指责我，说我傲慢。
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
其实在中国也有这样的表述：“以德报怨，何以报德？”
&lt;/p&gt;&lt;/div&gt;</description><category>film</category><guid>https://fpghwd.github.io/posts/kan-wan-dian-ying-gou-zhen-de-yi-dian-xiang-fa/</guid><pubDate>Mon, 23 Nov 2020 07:39:45 GMT</pubDate></item><item><title>Difference Since Using Doom Emacs</title><link>https://fpghwd.github.io/posts/since-use-doom-emacs/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
自从使用了 doom emacs 后，就很少纠结系统升级了。以前没事总是会升级一下，但是现在最多的就是可能想起来会升级一下 doom emacs, 只需要在 emacs 中 upgrade 和 reload 即可。其实大多数时候我也只是 doom sync 一下配置然后 reload 一下，最多也就十几二十秒。
&lt;/p&gt;

&lt;p&gt;
用 emacs 写东西简直是最近感觉最幸福的一件事情了。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/since-use-doom-emacs/</guid><pubDate>Wed, 04 Nov 2020 19:13:58 GMT</pubDate></item><item><title>Emacs Lisp Overlay</title><link>https://fpghwd.github.io/posts/emacs-lisp-overlay/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近看到 Emacs Lisp 里面 Overlay 的概念，可以用于自定义介面 buffer 的文字的某些特殊效果。
&lt;/p&gt;

&lt;p&gt;
当然其实对文字的编辑和模式本身都可以是文字内容的一种展现方式，但是文字的属性（Text Properties）是文字的一部分，overlay 并不是文字的一部分。所以在 buffer 之间复制某些文字的时候，并不会同时复制  overlay ；同时改变 buffer 的文字属性其实也是在修改 buffer 本身。但 overlay 的改变并不会改变 buffer 本身，这种修改自然也不会被保存在这个 buffer 的 undo list 中。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-lisp-overlay/</guid><pubDate>Mon, 26 Oct 2020 05:24:03 GMT</pubDate></item><item><title>Org archive location</title><link>https://fpghwd.github.io/posts/org-archive-location/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在使用 org 的时候想把 org-archive-subtree 的条目和 org-capture-templates 那样，将每次当天 archived 的 headline 放到当日的日期 headline 下面，和日记一样组织。这样的话，将来查询的时候就可以顺便看一下当天发生的事情和当天完成的项目了。
&lt;/p&gt;

&lt;p&gt;
以下是日记的组织方式：
&lt;/p&gt;

&lt;div id="org595b26c" class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/_20201016_192526screenshot.png" alt="_20201016_192526screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;
(add-to-list 'org-capture-templates
                      '("zj" "journal" entry (file "/home/wd/dropbox/to-encfs/text/org/journal.org")
                        "* %u - %^{heading}\n  %?"))

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
同时在 &lt;code&gt;customize org-archive-location&lt;/code&gt; 中发现了有这种设定：
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
"~/org/datetree.org::datetree/* Finished Tasks"
The "datetree/" string is special, signifying to archive
items to the datetree.  Items are placed in either the CLOSED
date of the item, or the current date if there is no CLOSED date.
The heading will be a subentry to the current date.  There doesn’t
need to be a heading, but there always needs to be a slash after
datetree.  For example, to store archived items directly in the
datetree, use "~/org/datetree.org::datetree/".

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
可以把日记和归档的条目都放到一个文件，归档也不会经常去动，只需要看的时候搜索一下就行。
&lt;/p&gt;&lt;/div&gt;</description><category>ATTACH</category><category>emacs</category><guid>https://fpghwd.github.io/posts/org-archive-location/</guid><pubDate>Fri, 16 Oct 2020 03:32:18 GMT</pubDate></item><item><title>Leetcode92. Reverse Linked List II</title><link>https://fpghwd.github.io/posts/leetcode92-reverse-linked-list-ii/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/reverse-linked-list-ii/"&gt;92. Reverse Linked List II&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
  public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        if (m == n) // 当 m = n 时并没有变化
            return head;

        int i = 1;
        ListNode *psuedo_head = new ListNode(), *pre = psuedo_head, *n_pre;

        for (ListNode *w = head; w;) {
            if (i &amp;lt;= m || i &amp;gt; n) {
                if (i == m)
                    n_pre = w;
                pre-&amp;gt;next = w;
                if (i != m)
                    pre = w;
                w = w-&amp;gt;next;
            } else if (i &amp;gt; m &amp;amp;&amp;amp; i &amp;lt;= n) {
                ListNode *tmp = w;
                w = w-&amp;gt;next;
                tmp-&amp;gt;next = pre-&amp;gt;next;
                pre-&amp;gt;next = tmp;
                if (i == n)
                    pre = n_pre;
            }
            i++;
        }

        pre-&amp;gt;next = nullptr; // 尾节点后续是 null

        return psuedo_head-&amp;gt;next;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (44/44)

Runtime: 4 ms, faster than 64.43% of C++ submissions.

Memory Usage: 7.8 MB, less than 16.96% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
第一次做的时候没想那么多，暴力的做法。后来做的时候就想到这是将链表的导致的前插和尾插组合在一起的题。并不难，只要分别搞清楚这两种写法就能写出来。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode92-reverse-linked-list-ii/</guid><pubDate>Mon, 05 Oct 2020 02:04:08 GMT</pubDate></item><item><title>Leetcode96. Unique Binary Search Trees</title><link>https://fpghwd.github.io/posts/leetcode96-unique-binary-search-trees/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/unique-binary-search-trees/"&gt;96. Unique Binary Search Trees&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;class Solution {
  public:
    int numTrees(int n) {
        if (n == 0 || n == 1)return 1;

        int count = 0;
        for (int i = 1; i &amp;lt;= n; i++)count += numTrees(i - 1) * numTrees(n - i);

        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (19/19)

Runtime: 1220 ms, faster than 11.92% of C++ submissions.

Memory Usage: 6 MB, less than 59.10% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
用 DP 做更快一点，但递归对理解更友好些。反过来， DP 不就是递归的递推公式的代数形式嘛。能用递归就做出来的事情，就不需要迭代了，毕竟&lt;a href="http://algosaur.us/recursion/"&gt;“To iterate is human, to recurse, divine”&lt;/a&gt;. 能请神去做的事情，就不要麻烦人啦。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode96-unique-binary-search-trees/</guid><pubDate>Wed, 30 Sep 2020 20:39:40 GMT</pubDate></item><item><title>Leetcode824. Goat Latin</title><link>https://fpghwd.github.io/posts/leetcode824-goat-latin/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/goat-latin/"&gt;824. Goat Latin&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
class Solution {
  public:
    string toGoatLatin(string S) {
        int start = 0, end = 0, i = 1;
        string goat = "";
        while (start &amp;lt; S.length()) {
            if (i != 1)
                goat += " ";
            while (end &amp;lt; S.length() &amp;amp;&amp;amp; isalpha(S[end]))
                end++;
            if (S[start] == 'a' || S[start] == 'e' || S[start] == 'i' ||
                S[start] == 'o' || S[start] == 'u' || S[start] == 'A' ||
                S[start] == 'E' || S[start] == 'I' || S[start] == 'O' ||
                S[start] == 'U') {
                goat += S.substr(start, end - start);
            } else {
                if (start + 1 != end) {
                    goat += S.substr(start + 1, end - start - 1);
                }
                goat += S.substr(start, 1);
            }
            goat += "ma";
            goat += string(i, 'a');

            end++, start = end, i++;
        }
        return goat;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (99/99)

Runtime: 0 ms, faster than 100.00% of C++ submissions.

Memory Usage: 6.6 MB, less than 76.77% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
字符串的題目都是用指針來做的。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode824-goat-latin/</guid><pubDate>Tue, 29 Sep 2020 02:01:13 GMT</pubDate></item><item><title>Leetcode572. Subtree of Another Tree</title><link>https://fpghwd.github.io/posts/leetcode572-subtree-of-another-tree/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/subtree-of-another-tree/"&gt;572. Subtree of Another Tree&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
  public:
    bool isSubtree(TreeNode *s, TreeNode *t) {
        // return isSameTree(s, t) || isSameTree(s-&amp;gt;left, t) ||
        //        isSameTree(s-&amp;gt;right, t);
        if (s == NULL &amp;amp;&amp;amp; t == NULL)
            return true;
        if (s == NULL)
            return false;
        if (t == NULL)
            return true;
        bool isSub;
        if (s-&amp;gt;val == t-&amp;gt;val)
            isSub = isSameTree(s, t);
        if (isSub)
            return true;
        return isSubtree(s-&amp;gt;left, t) || isSubtree(s-&amp;gt;right, t);
    }

    bool isSameTree(TreeNode *s, TreeNode *t) {
        if (s == nullptr &amp;amp;&amp;amp; t == nullptr) {
            return true;
        } else {
            if (s == nullptr || t == nullptr)
                return false;
            if (s-&amp;gt;val != t-&amp;gt;val)
                return false;
            else
                return isSameTree(s-&amp;gt;left, t-&amp;gt;left) &amp;amp;&amp;amp;
                       isSameTree(s-&amp;gt;right, t-&amp;gt;right);
        }
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (183/183)

Runtime: 40 ms, faster than 66.02% of C++ submissions.

Memory Usage: 29.7 MB, less than 18.21% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
第一次做的时候并没有做对，第二次倒是 AC 了。没啥感觉，就是感觉自己的方法代码有点复杂。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode572-subtree-of-another-tree/</guid><pubDate>Tue, 29 Sep 2020 00:20:04 GMT</pubDate></item><item><title>Leetcode093. Restore IP Addresses</title><link>https://fpghwd.github.io/posts/leetcode093-restore-ip-addresses/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/restore-ip-addresses/"&gt;93. Restore IP Addresses&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
class Solution {
  public:
    vector&amp;lt;string&amp;gt; addresses;
    vector&amp;lt;string&amp;gt; restoreIpAddresses(string s) {
        vector&amp;lt;string&amp;gt; path;
        dfs(s, path);
        return addresses;
    }

    void dfs(string s, vector&amp;lt;string&amp;gt; &amp;amp;path) {

        if (s == "" &amp;amp;&amp;amp; path.size() == 4) {
            string tmp = "";
            for (string s : path) {
                if (tmp != "")
                    tmp += ".";
                tmp += s;
            }
            addresses.push_back(tmp);
            return;
        }

        if (path.size() &amp;gt; 4 || s == "")
            return;

        for (int i = 1; i &amp;lt;= s.length(); i++) {
            string ip = s.substr(0, i);
            if (i &amp;gt; 1 &amp;amp;&amp;amp; s[0] == '0')
                return;
            if (stoi(ip) &amp;gt; 255)
                break;
            path.push_back(ip);
            dfs(s.substr(i, s.length() - i), path);
            path.pop_back();
        }
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (147/147)

Runtime: 4 ms, faster than 81.89% of C++ submissions.

Memory Usage: 7.6 MB, less than 13.80% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
第一次嘗試是忽略了 10.0.010.0 中的 010 是不能作爲一個符合要求的 ip 段。所以添加了
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;if (i &amp;gt; 1 &amp;amp;&amp;amp; s[0] == '0')
    return;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
這一段，雖然丑但是很有用。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode093-restore-ip-addresses/</guid><pubDate>Mon, 28 Sep 2020 07:12:03 GMT</pubDate></item><item><title>Leetcode543. Diameter of Binary Tree</title><link>https://fpghwd.github.io/posts/leetcode528-diameter-of-binary-tree/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/diameter-of-binary-tree/"&gt;543. Diameter of Binary Tree&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
  public:
    int diameter = 0;
    int diameterOfBinaryTree(TreeNode *root) {
        depthTravel(root);
        return diameter;
    }
    int depthTravel(TreeNode *root) {
        if (root == nullptr)
            return 0;
        int left = depthTravel(root-&amp;gt;left);
        int right = depthTravel(root-&amp;gt;right);
        diameter = max(left + right, diameter);
        return 1 + max(left, right);
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
Status: Accepted (106/106)

Runtime: 12 ms, faster than 88.39% of C++ submissions.

Memory Usage: 21 MB, less than 13.09% of C++ submissions.

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
同樣的是一個樹遍歷的題目。不過第一次做的時候因爲想用一個函數解決問題，但是好像是不行的。因爲遞歸返回值如果是最長的直徑的話，就無法只用一個單一的返回值來構造這個函數，又不能修改參數。所以遞歸函數的返回值需要更多的信息，因此還是藉助了返回值爲結點高度的函數 &lt;code&gt;depthTravel&lt;/code&gt; 。&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode528-diameter-of-binary-tree/</guid><pubDate>Sun, 27 Sep 2020 20:21:11 GMT</pubDate></item></channel></rss>