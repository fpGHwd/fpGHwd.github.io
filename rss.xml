<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dichotomy</title><link>https://fpghwd.github.io/</link><description>To iterate is human, to recurse, divine</description><atom:link href="https://fpghwd.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:ggwdwhu@gmail.com"&gt;suzumiya natsuhi&lt;/a&gt; </copyright><lastBuildDate>Tue, 15 Sep 2020 02:51:32 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Leetcode589 N-ary Tree Preorder Traversal</title><link>https://fpghwd.github.io/posts/leetcode742-n-ary-tree-preorder-traversal/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal"&gt;589. N-ary Tree Preorder Traversal&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
class Solution {
    public:
        vector&amp;lt;int&amp;gt; preorder(Node* root) {
            if(root==nullptr)return preorder_vi;
            preorder_vi.push_back(root-&amp;gt;val);
            for(Node* n:root-&amp;gt;children){
                preorder(n);
            }
            return preorder_vi;
        }
    private:
        vector&amp;lt;int&amp;gt; preorder_vi;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
虽然这个返回有点丑陋，不想写第二个函数，尽管感觉总是怪怪的。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;更新：&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
奇怪主要因为这个 &lt;code&gt;preorder_vi&lt;/code&gt; 的返回看起来有点多余，可能以前习惯写的遍历都是返回 &lt;code&gt;void&lt;/code&gt; ，导致有这样的错觉。
&lt;/p&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode742-n-ary-tree-preorder-traversal/</guid><pubDate>Mon, 14 Sep 2020 04:09:43 GMT</pubDate></item><item><title>Leetcode893 IncreasingOrderSearch Tree</title><link>https://fpghwd.github.io/posts/leetcode893-increasingordersearch-tree/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/increasing-order-search-tree/"&gt;893. IncreasingOrderSearch Tree&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;
class Solution {
    public:
        TreeNode* increasingBST(TreeNode* root) {
            if(root == nullptr)return nullptr;
            TreeNode *first = root, *last = root;
            inOrderRecursion(root, first, last);
            return first;
        }

       void inOrderRecursion(TreeNode* root,TreeNode*&amp;amp; first, TreeNode*&amp;amp; last){

           if(root == nullptr)return;
           TreeNode *first1, *last1;

           if(root-&amp;gt;left){
               last1 = root-&amp;gt;left;
               first = root-&amp;gt;left;
               inOrderRecursion(root-&amp;gt;left, first, last1);
               last1-&amp;gt;left = nullptr; last1-&amp;gt;right=root;
           }
           if(root-&amp;gt;right){
               first1 = root-&amp;gt;right;
               last = root-&amp;gt;right;
               inOrderRecursion(root-&amp;gt;right,first1,last);
               root-&amp;gt;left = nullptr; root-&amp;gt;right = first1;
           }
        }

};

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode893-increasingordersearch-tree/</guid><pubDate>Sun, 13 Sep 2020 01:10:47 GMT</pubDate></item><item><title>Leetcode1200 minimum absolute difference</title><link>https://fpghwd.github.io/posts/leetcode1200-minimum-absolute-difference/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://leetcode.com/problems/minimum-absolute-difference/"&gt;1200. Minimum Absolute Difference&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Solution&lt;/b&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-C"&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; minimumAbsDifference(vector&amp;lt;int&amp;gt;&amp;amp; arr) {
        sort(arr.begin(), arr.end());
        int v = -1;
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; mad;
        for(int i = 0; i + 1 &amp;lt; arr.size(); i++){
            vector&amp;lt;int&amp;gt; tmp;
            if( v == -1 || arr[i+1] - arr[i] &amp;lt; v){
                mad.clear();
                mad.push_back(vector&amp;lt;int&amp;gt;{arr[i],arr[i+1]});
                v = arr[i+1] - arr[i];
            }else{
                if(arr[i+1] - arr[i] == v){
                    mad.push_back(vector&amp;lt;int&amp;gt;{arr[i],arr[i+1]});
                }
            }
        }
        return mad;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>leetcode</category><guid>https://fpghwd.github.io/posts/leetcode1200-minimum-absolute-difference/</guid><pubDate>Fri, 11 Sep 2020 19:43:01 GMT</pubDate></item><item><title>Ignorant and tolerant</title><link>https://fpghwd.github.io/posts/ignorant-and-tolerant/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
如果把宽容理解成行为的话，那么有两个和这种行为相关的 无知相关的宽容 和 尊重相关的宽容。
&lt;/p&gt;

&lt;p&gt;
其实两者在大多数情况看来并没有区别，两者形成在表面上相通的宽容行为。假设一种情况：有人请我喝酒，我说不喝，而请我啤酒的人只是说 “好吧”，她也没有打扰我，甚至没有问我，我怎么能确定她尊重我的选择呢？如果不知道的话，那谈论这两点又有什么意义呢？
&lt;/p&gt;

&lt;p&gt;
尊重相关的宽容往往是这样的：我们尊重别人的价值和独特性，因为我们理解并有意识地意识到这是他们的独特之处。而另一方面：无知是一种不打扰他人行为的行为，因为我们不关心，甚至更麻烦。
&lt;/p&gt;

&lt;p&gt;
尊重的宽容鼓励沟通和相互理解，而无知的宽容则会引发假设和判断。
&lt;/p&gt;

&lt;p&gt;
&lt;del&gt;表面上看来，无知的宽容像是 “不知者不罪”；但很多场合下，“雪崩下每一片雪花都有在助力”。&lt;/del&gt; 在危机时，尤其是当我们的自我受到干扰的时候，我们自己对生活的看法就会受到挑战。那么，所有与他人不一样的生命价值的差异，都会莫名其妙地浮现出来，变得清晰可见。在这种情况下，无知（的宽容）将导致我们更加判断。在更糟的环境下，他们的价值会被我们忽视和虐待。同时，尊重的宽容会使我们仍然给予尊重，而不是刻板地认为那些有同样价值的人也可以做同样的事情。在喝酒的例子中，很可能是这样：给我饮料的人认定了我的拒绝，并 &lt;b&gt;判断&lt;/b&gt; 我有点认真/不好玩，或者可能不尊重人。
&lt;/p&gt;

&lt;p&gt;
信息越闭塞下的宽容，很可能是无知的宽容；而信息闭塞情况下仍保持尊重的宽容的人，难能可贵。
&lt;/p&gt;

&lt;p&gt;
所以真正值得发展的宽容应该是尊重相关的宽容。
&lt;/p&gt;&lt;/div&gt;</description><guid>https://fpghwd.github.io/posts/ignorant-and-tolerant/</guid><pubDate>Tue, 08 Sep 2020 18:06:30 GMT</pubDate></item><item><title>Questions that create reality</title><link>https://fpghwd.github.io/posts/questions-that-create-reality/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
一个穷人带自己的小孩去读书。
老师：“识字吗？”
穷人：“不识字。”
老师：“不识字读什么书？”
穷人：“就是因为不识字才要读书啊！”
&lt;/p&gt;

&lt;p&gt;
老师站在自己的逻辑（强者逻辑，自己的成本），认为基础不好的就没有必要再读书了。
穷人的回答正好是自己立场的体现：就是因为不识字，才更要读书。
两种逻辑看起来都没有问题。矛盾就出现了：一个问题，两个人得出截然相反的结论。为什么呢？
&lt;/p&gt;

&lt;p&gt;
那是因为立场的转换，当我们理解老师的逻辑时，是站在老师的立场的（基础差的学生有什么好学的）；当我们理解穷人的逻辑时，是站在穷人的立场的（正是基础差才更要学的）。立场的转换让两句话逻辑本身都看起来没问题。
老师不过是一个身份，换成“强者”是一个简单的替换。“识字”也只不过很常见的场景中的一种而已。
&lt;/p&gt;

&lt;p&gt;
其实讽刺的还是明明自己是弱者的一方，还误把自己在强者的立场。这不就是把弱者自己推入万劫不复的境地吗？弱者一遍一遍地重复强者逻辑，没有自我思维，只能陷入没有希望的境地。
这个笑话自己深刻的体现了穷人的自我意识：正是因为没有才会去追求，这就是人类。
然而自我思维，说到底不过是人性而已。强者拥有自己的逻辑，弱者重复他的逻辑，不知不觉间就失去了自我意识，也失去了人性。
事实上，强者坚持自己的逻辑是坚持自己的人性，而弱者坚持强者的逻辑而放弃自己的逻辑，不过是将自己的人性拱手让人罢了。根本都怪不了任何人。放弃自己人性相当于放弃自己的自我意识，没有自我意识，梦想什么的就更不用空谈了。
&lt;/p&gt;

&lt;p&gt;
当今“某国需不需要民主”这种问题，我觉得已经不需要回答了。“素质低的国民不需要民主”和“素质低的国民更需要民主”正是以上一个镜像立场对。虽然我只举了强者和弱者的例子，生活中不会只有强者和弱者，更应该有的是各种具有系统思维的独立思维个体。
&lt;/p&gt;

&lt;p&gt;
而生活中也大量充斥大量的这样的问题。如果你发现别人不希望你做某件事的时候，你的自我意识觉醒就更想去做成这件事。当然前提是你知道“别人不希望你做这件事”，这包含一个搜集资料的过程。对于一个信息公开的环境，别人的逻辑似乎就不那么重要了，你会越听从于自己的内心和自己的观点。
另一方面，提出类似的问题也是你在完成这件事的一个阶段，而不是什么都没做，是在努力解决这个问题的一个重要环节。
&lt;/p&gt;

&lt;p&gt;
当然，如果一开始你就知道你不必看重任何人的观点，只需要了解一下其他人的观点即可，就不用纠结在别人的立场纷争中了，更早些走上自己想走的那条路了。想必这个平行时空中，所有的事物都发展得比较快和更理性吧。
&lt;/p&gt;

&lt;p&gt;
好的问题正是根本都不需要回答的问题吧，因为答案不过是一些立场而已。但最重要的是有自己的立场，而不是人云亦云随波逐流。
同时好的问题是激发人的思考的问题：Questions that create reality.
&lt;/p&gt;&lt;/div&gt;</description><category>life</category><guid>https://fpghwd.github.io/posts/questions-that-create-reality/</guid><pubDate>Wed, 02 Sep 2020 19:05:43 GMT</pubDate></item><item><title>Courage and Self</title><link>https://fpghwd.github.io/posts/courage-and-self/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
When I look back to past time without courage, the only thing I cannot forget is I didn’t tell the teacher beside me to stop ticking her shoes upon chair in NHEEE. For me, it’s an apparent evidence that lacking courage is my weakness.
&lt;/p&gt;

&lt;p&gt;
如果再有那么一次机会的话，我会选择很直接的表达出来，而不是让这些东西默默成为困扰自己的一部分。因为我觉得这开了一个坏头，造成后面有一些事也发展成类似结果。我认为是自我意识的不足导致的，勇气是自我意识的一个重要的组成部分。
&lt;/p&gt;&lt;/div&gt;</description><category>life</category><guid>https://fpghwd.github.io/posts/courage-and-self/</guid><pubDate>Mon, 31 Aug 2020 08:20:23 GMT</pubDate></item><item><title>No news is good news</title><link>https://fpghwd.github.io/posts/no-news-is-good-news/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
今天看书看到了在如何在应用程序中加载/链接共享库，书中以高性能 Web 服务器的例子来说明，对于一个繁忙的网站，运行时加载和链接共享库对于服务质量的提升意义重大。
&lt;/p&gt;

&lt;p&gt;
加载和链接共享库用到的是 &lt;code&gt;dlfcn.h&lt;/code&gt; 中的 &lt;code&gt;dlopen/dlsym/dlclose&lt;/code&gt; 的三个函数。还有最后一个检查前面三个调用情况的函数： &lt;code&gt;dlerror&lt;/code&gt; ，声明为：
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-cpp"&gt;const char *dlerror(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="file:///home/wd/Dropbox/text/org/.attach/44/fb0c61-59f7-4c20-b6a3-9670b19c059b/_20200825_110429screenshot.png" alt="_20200825_110429screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
如果调用前三个函数没有发生错误，则返回NULL。我想起了以前看过的K&amp;amp;R的函数返回值如果为0则是运行成功，当时还特意想着为什么这么来设计，还学到了标题的那句话“没有消息就是好消息”。
&lt;/p&gt;

&lt;p&gt;
当然其实要说：“成功都是一样的，失败各有各的不同的原因”也是没有问题的，毕竟比“失败都是一样的，成功各有各的不同”这句话要更为实诚一点。我觉得这说明从失败中获取原因是有价值的，而从成功中找原因应该没有什么大的价值吧。怎么回事，好像顺手黑了成功学一把，这不是我的本意。
&lt;/p&gt;&lt;/div&gt;</description><category>ATTACH</category><category>csapp</category><guid>https://fpghwd.github.io/posts/no-news-is-good-news/</guid><pubDate>Mon, 24 Aug 2020 18:52:31 GMT</pubDate></item><item><title>Recent status in July of 2020</title><link>https://fpghwd.github.io/posts/recent-status/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
Recently I learn a word “If I have seen further, it is by standing on the shoulders of giants.”, which is from Sir Isaac Newton. Though I heard it long time ago, I learn new from it when reading it again now. 
&lt;/p&gt;

&lt;p&gt;
Recently days maybe darkest days in my life that has passed. Fear, unknown, and extremely wandering and not focusing on urgent stuffs made me unhappy. And I had time to chew and  classify these feelings, and most of which were just not willing to step into unknown fields. It’s critical for positive attitude and deeds in life and many things. 
&lt;/p&gt;

&lt;p&gt;
I hope I would have handled it better, though there is no chance for me to handle them once again. When next case, I hope I can do the same as “learn war in war”.
&lt;/p&gt;

&lt;p&gt;
λλλλλλ
&lt;/p&gt;&lt;/div&gt;</description><category>life</category><guid>https://fpghwd.github.io/posts/recent-status/</guid><pubDate>Tue, 28 Jul 2020 03:06:55 GMT</pubDate></item><item><title>How openSUSE rollbacks when using brtfs</title><link>https://fpghwd.github.io/posts/how-opensuse-rollback-when-using-brtfs/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Brtfs&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Btrfs, an abbreviation for b-tree file system. By default, openSUSE is set up using Btrfs and snapshots for the root partition. Snapshots allow you to easily roll back your system if needed after applying updates, or to back up files. Snapshots can easily be managed with Snapper.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Yast Filesystem Snapshots&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In yast Filesystem Snapshots, sensitive changes in system files(directories in / like /etc, /bin, excluding /home) will be listed and You can check difference between pre-changed status and post-changed status. One can specify the volumn to rollback via time or file(s’) changes.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Rollback&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Boot and on grub(2) interface, choose “Advance bootloader for openSUSE” and enter in and choose item you want to rollback to. And then “openSUSE Tumbleweed” to boot normally. Login and run &lt;code&gt;sudo snapper rollback &amp;amp;&amp;amp; reboot&lt;/code&gt; in opened terminal, then relogin. And everything is OK.
&lt;/p&gt;&lt;/div&gt;</description><category>openSUSE</category><guid>https://fpghwd.github.io/posts/how-opensuse-rollback-when-using-brtfs/</guid><pubDate>Mon, 13 Jul 2020 07:16:58 GMT</pubDate></item><item><title>Manage workgroups in emacs via workgroups2</title><link>https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/</link><dc:creator>suzumiya natsuhi</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;b&gt;Workgroups2&lt;sup&gt;&lt;a id="fnr.1" class="footref" href="https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/#fn.1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/b&gt; 
Workgroups2 是一款保存和恢复用户工作空间的一款 emacs 插件。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;sessions 和 workgroups&lt;/b&gt; 
这里的 session 指的是 emacs 里面的 buffer 的一个集合，甚至 buffer 的指针的状态即位置。workgroups 与用户的工作相关，指的是用户指定的显示 buffer 和 buffer 的状态集合。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;如何管理：group 的创建/修改/删除&lt;/b&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;wg-create-group&lt;/code&gt; 用于创建一个 group（比如 cpp-dev），可以用 &lt;code&gt;wg-rename-group&lt;/code&gt; 修改 group 的名字，然后使用 &lt;code&gt;wg-save-session&lt;/code&gt; 将当前的 group 的状态保存入文件中（比如 &lt;code&gt;~/.emacs_workgroups&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wg-rename-group&lt;/code&gt; 用于修改 group 的名字，然后用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。同时如果想保存指针（cursor）在另一个位置的状态，需要重新用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wg-kill-workgroup&lt;/code&gt; 用于删除打开的 group，同时完成后用 &lt;code&gt;wg-save-session&lt;/code&gt; 保存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;b&gt;意义&lt;/b&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;在多个 workgroups 之间切换将会变得很容易。当然可以使用 &lt;code&gt;C-x b&lt;/code&gt; 来切换 buffer，但是使用了 workgroups 后一次切换到你所指定的所需 buffer 集合，将是一个极大的效率提升。&lt;/li&gt;
&lt;li&gt;保存共享同步 workgroups。这个是一个次要的提升，由于在不同环境中的文件可能不同，buffer 是否能够正常打开并不确定。如果依赖同步来同步整个环境的话我感觉没有必要，毕竟在对应的环境中做什么事情效率更高一些。&lt;/li&gt;
&lt;/ol&gt;

&lt;div id="footnotes"&gt;
&lt;h3 class="footnotes"&gt;Footnotes: &lt;/h3&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.1" class="footnum" href="https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/#fnr.1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
&lt;a href="https://github.com/pashinin/workgroups2"&gt;Workgroups2的Github主页&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>workgroups2</category><guid>https://fpghwd.github.io/posts/shi-yong-workgroups2-guan-li-emacs-de-session/</guid><pubDate>Thu, 09 Jul 2020 02:08:16 GMT</pubDate></item></channel></rss>